/**
 * @file packages/core/src/logic/symbolGraph/passes/2_discoverSymbols.ts
 * @architectural-role Symbol Discovery Pass
 *
 * @description This module is responsible for the second pass of the symbol graph
 * generation process. Its purpose is to traverse the cached ASTs to identify all
 * top-level symbol declarations and create the initial, unconnected nodes for them
 * in the graph.
 *
 * @responsibilities
 * 1.  **AST Traversal:** It iterates through every AST in the provided `astCache`.
 * 2.  **Node Creation:** For each file, it first ensures a file-level `SymbolNode`
 *     exists in the graph.
 * 3.  **Symbol Identification:** It uses `@babel/traverse` to visit specific node
 *     types that represent declarations (e.g., `FunctionDeclaration`, `ClassDeclaration`,
 *     top-level `VariableDeclaration`, `ExportDefaultDeclaration`).
 * 4.  **Graph Population:** For each symbol it discovers, it creates a new `SymbolNode`
 *     and adds it to the `graph` map. At the end of this pass, the graph contains
 *     all the nodes but none of the connecting edges (dependencies).
 */
import traverse, { NodePath } from '@babel/traverse';
import type {
  Node,
  FunctionDeclaration,
  ClassDeclaration,
  TSEnumDeclaration,
  TSInterfaceDeclaration,
  TSTypeAliasDeclaration,
  VariableDeclaration,
} from '@babel/types';
import type { SymbolGraph } from '../types';

type AstCache = Map<string, Node>;

/**
 * Pass 2: Discovers all top-level symbols and creates nodes for them in the graph.
 * @param astCache - The cache of ASTs generated by Pass 1.
 * @param graph - The graph instance to be populated. This function mutates the graph.
 */
export function discoverSymbols(astCache: AstCache, graph: SymbolGraph): void {
  for (const [filePath, ast] of astCache.entries()) {
    // Ensure a file-level node exists for every file.
    if (!graph.has(filePath)) {
      graph.set(filePath, {
        id: filePath,
        filePath: filePath,
        symbolName: '(file)',
        dependencies: new Set(),
        dependents: new Set(),
      });
    }

    // Helper to create a new symbol node if it doesn't already exist.
    const createNode = (name: string) => {
      const id = `${filePath}#${name}`;
      if (!graph.has(id)) {
        graph.set(id, {
          id,
          filePath: filePath,
          symbolName: name,
          dependencies: new Set(),
          dependents: new Set(),
        });
      }
    };

    const declarationVisitor = (
      path: NodePath<
        FunctionDeclaration | ClassDeclaration | TSEnumDeclaration | TSInterfaceDeclaration | TSTypeAliasDeclaration
      >
    ) => {
      if (path.node.id?.name) {
        createNode(path.node.id.name);
      }
    };

    traverse(ast, {
      FunctionDeclaration: declarationVisitor,
      ClassDeclaration: declarationVisitor,
      TSEnumDeclaration: declarationVisitor,
      TSInterfaceDeclaration: declarationVisitor,
      TSTypeAliasDeclaration: declarationVisitor,
      VariableDeclaration(path: NodePath<VariableDeclaration>) {
        // Only consider variables declared at the top level of the module.
        if (path.parent.type === 'Program' || path.parent.type === 'ExportNamedDeclaration') {
          for (const decl of path.node.declarations) {
            if (decl.id.type === 'Identifier') {
              createNode(decl.id.name);
            }
          }
        }
      },
      ExportDefaultDeclaration() {
        createNode('default');
      },
    });
  }
}