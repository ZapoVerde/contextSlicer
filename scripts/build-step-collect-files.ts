/**
 * @file packages/context-slicer-app/scripts/build-step-collect-files.ts
 * @stamp {"ts":"2025-10-13T10:07:07.491Z"}
 * @architectural-role Utility
 * @description
 * This module is responsible for finding all relevant source files in the target
 * repository. It starts its scan from the `REPO_ROOT` path provided by the central
 * configuration module, which is now dynamically pointed at the user's project.
 * @api-declaration
 *   // (Auto-generated by audit script)
 * @contract
 *   assertions:
 *     purity: mutates # This script reads from the filesystem.
 *     external_io: none # It only interacts with the local filesystem.
 */

import fs from 'fs';
import path from 'path';
import * as config from './config.js';
import { walkDir } from './file-utils.js';

// Define a clear type for the file objects we're working with.
export interface SourceFile {
  path: string;
  bytes: number;
}

/**
 * Walks the repository directory to find all files that are not excluded by the ignore rules.
 * @returns {SourceFile[]} An array of file objects.
 */
export function collectSourceFiles(): SourceFile[] {
  const collected: SourceFile[] = [];

  walkDir(config.REPO_ROOT, (fullPath: string, isDir: boolean) => {
    // We only care about files, not directories.
    if (!isDir) {
      const relPath: string = path.relative(config.REPO_ROOT, fullPath).replace(/\\/g, '/');
      const stats: fs.Stats = fs.statSync(fullPath);
      collected.push({ path: relPath, bytes: stats.size });
    }
  });

  // Sort the final list for consistent ordering in concatenated files.
  collected.sort((a, b) => a.path.localeCompare(b.path));

  return collected;
}

/**
 * Groups a flat list of file entries by their parent directories.
 * A file in 'a/b/c.txt' will be included in the group for 'a' and the group for 'a/b'.
 * @param {SourceFile[]} files - The flat list of collected files.
 * @returns {Map<string, SourceFile[]>} A map where keys are folder paths
 * and values are arrays of file objects belonging to that folder and its subfolders.
 */
export function groupFilesByFolder(files: SourceFile[]): Map<string, SourceFile[]> {
  const map = new Map<string, SourceFile[]>();

  // Helper to add a file to a group, creating the group if it doesn't exist.
  const add = (folderKey: string, file: SourceFile): void => {
    if (!map.has(folderKey)) {
      map.set(folderKey, []);
    }
    map.get(folderKey)!.push(file);
  };

  for (const file of files) {
    const parts: string[] = file.path.split('/');

    // If the file is in the root, it belongs to the special '(repo root)' group.
    if (parts.length === 1) {
      add('', file); // Use empty string as the key for the repo root.
      continue;
    }

    // For a file 'a/b/c.js', add it to the group for 'a' and the group for 'a/b'.
    for (let i = 1; i < parts.length; i++) {
      const folder: string = parts.slice(0, i).join('/');
      add(folder, file);
    }
  }

  // Ensure files within each group are sorted alphabetically for consistent output.
  for (const arr of map.values()) {
    arr.sort((a, b) => a.path.localeCompare(b.path));
  }

  return map;
}