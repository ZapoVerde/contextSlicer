/**
 * @file packages/context-slicer-app/scripts/config.ts
 * @stamp {"ts":"2025-10-13T10:02:49.213Z"}
 * @architectural-role Configuration
 * @description
 * This module is the build system's primary path-derivation engine. It bootstraps
 * the configuration by loading `slicer-config.yaml` from a fixed relative path.
 * It then uses the `targetProjectRoot` from that config to define the
 * authoritative `REPO_ROOT` for the analysis, while deriving all of the tool's
 * own internal paths from its inferred location, making the system self-contained.
 * @api-declaration
 *   // (Auto-generated by audit script)
 * @contract
 *   assertions:
 *     purity: mutates # This script reads from the filesystem, a side effect.
 *     external_io: none # It only interacts with the local filesystem.
 */

import path from 'path';
import fs from 'fs';
import yaml from 'js-yaml';
import { fileURLToPath } from 'url';
import type { SlicerConfig } from '../src/features/context-slicer/state/zip-state.ts';

// --- Phase 1: Bootstrap and Self-Discovery ---

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const SLICER_APP_ROOT = path.resolve(__dirname, '..');
const CONFIG_FILE_PATH = path.join(SLICER_APP_ROOT, 'public/slicer-config.yaml');

let slicerConfig: SlicerConfig;

try {
  const configFile = fs.readFileSync(CONFIG_FILE_PATH, 'utf8');
  slicerConfig = yaml.load(configFile) as SlicerConfig;
  if (!slicerConfig?.project?.targetProjectRoot) {
    throw new Error('`project.targetProjectRoot` is missing or invalid.');
  }
} catch (error: unknown) {
  console.error('---------------------------------------------------------');
  console.error('FATAL ERROR: Could not load or parse `slicer-config.yaml`');
  console.error(`Attempted to read from: ${CONFIG_FILE_PATH}`);
  if (error instanceof Error) {
    console.error(`Reason: ${error.message}`);
  }
  console.error('Please ensure the file exists and is valid YAML.');
  console.error('---------------------------------------------------------');
  process.exit(1);
}

// --- Phase 2: Path Derivation ---

// The authoritative root of the EXTERNAL project to be analyzed.
export const REPO_ROOT: string = path.resolve(
  path.dirname(CONFIG_FILE_PATH),
  slicerConfig.project.targetProjectRoot
);

// All of the tool's OWN internal paths, derived from its own location.
export const PUBLIC_DIR: string = path.join(SLICER_APP_ROOT, 'public');
export const DUMP_ROOT: string = path.join(PUBLIC_DIR, 'source-dump', '_full-dump');
export const FOLDERS_DIR: string = path.join(DUMP_ROOT, 'folders');

// --- Phase 3: Export Constants ---

// URL Constants (for the manifest)
export const DUMP_BASE_URL: string = '/source-dump/_full-dump';
export const FOLDERS_BASE_URL: string = 'folders';

// Filesystem Targets (temporary paths for build artifacts)
export const CONCAT_TXT_PATH: string = path.join(DUMP_ROOT, 'source-dump.txt');
export const CONCAT_ZIP_PATH: string = path.join(DUMP_ROOT, 'source-dump.zip');

// File Content Markers (from config)
export const BEGIN_SIG: string = slicerConfig.output.beginMarker;
export const END_SIG: string = slicerConfig.output.endMarker;

// Export the entire loaded configuration object for other modules
export { slicerConfig };