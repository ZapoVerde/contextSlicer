/**
 * @file packages/context-slicer-app/scripts/build-step-generate-concat-txt.ts
 * @architectural-role Build Step / Artifact Generator
 *
 * @description This module is responsible for creating the single, large, concatenated text file (`source-dump.<hash>.txt`). It iterates through all collected source files, reads their content, and appends it to a single string, separating each file with clear markers. The final file is given a unique name based on its content hash to allow for effective caching.
 *
 * @core-principles
 * 1. **MUST** accept the flat list of collected files as input.
 * 2. **MUST** create a single text file containing the content of all input files.
 * 3. **MUST** wrap each file's content with the `BEGIN_SIG` and `END_SIG` markers from the config.
 * 4. **MUST** handle errors when reading files (e.g., for binary files) gracefully.
 * 5. **MUST** use the `getFileHash` utility to generate a content-based hash for the final filename.
 * 6. **MUST** return the final, hashed filename (e.g., "source-dump.a1b2c3d4.txt").
 */

import fsp from 'fs/promises';
import path from 'path';
import * as config from './config.ts';
import * as utils from './file-utils.ts';
import type { SourceFile } from './build-step-collect-files.ts';

/**
 * Creates a single text file containing the content of all collected source files.
 * The final filename is hashed for cache-busting.
 * @param {SourceFile[]} collectedFiles - The flat list of all files to include.
 * @returns {Promise<string>} A promise that resolves to the final hashed filename.
 */
export async function generateConcatTxt(collectedFiles: SourceFile[]): Promise<string> {
  const watermark: string = `// THIS FILE WAS GENERATED BY dump-src.js AT ${new Date().toISOString()}\n\n`;
  const lines: string[] = [watermark];

  for (const { path: relPath } of collectedFiles) {
    lines.push(`${config.BEGIN_SIG}${relPath}`);
    try {
      // Attempt to read the file as UTF-8 text.
      const content: string = await fsp.readFile(path.join(config.REPO_ROOT, relPath), 'utf8');
      lines.push(content);
    } catch (err: unknown) {
      // If reading as text fails, it's likely a binary file or has an encoding issue.
      // Log an error message in its place. We don't include binary content here.
      const error = err as Error;
      lines.push(`// ERROR reading file as text: ${error.message || String(error)}`);
    }
    lines.push(config.END_SIG);
    lines.push(''); // Add a blank line for readability between files.
  }

  // Ensure the destination directory exists before writing.
  await utils.ensureDir(path.dirname(config.CONCAT_TXT_PATH));

  // Write the combined content to a temporary, unhashed path first.
  await fsp.writeFile(config.CONCAT_TXT_PATH, lines.join('\n'), 'utf8');

  // Calculate the hash of the generated file.
  const hash: string = utils.getFileHash(config.CONCAT_TXT_PATH);
  const finalConcatTxtUrl: string = `source-dump.${hash}.txt`;
  const finalPath: string = path.join(config.DUMP_ROOT, finalConcatTxtUrl);

  // Rename the temporary file to its final, hashed name.
  await fsp.rename(config.CONCAT_TXT_PATH, finalPath);

  return finalConcatTxtUrl;
}