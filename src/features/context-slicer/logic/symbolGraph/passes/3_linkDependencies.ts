/**
 * @file src/features/sourceDump/logic/symbolGraph/passes/3_linkDependencies.ts
 * @architectural-role Dependency Linking Pass
 *
 * @description This module is responsible for the third and final pass of the symbol
 * graph generation process. Its purpose is to connect the nodes created in Pass 2 by
 * analyzing `import` statements and resolving dependencies.
 *
 * @responsibilities
 * 1.  **AST Traversal:** It iterates through every AST in the provided `astCache`,
 *     specifically looking for `ImportDeclaration` nodes.
 * 2.  **Dependency Resolution:** For each imported symbol, it uses the `PathResolver`
 *     and the `resolveExport` utility to trace the import back to the original file
 *     and symbol where it was declared.
 * 3.  **Graph Linking:** When a dependency is successfully resolved, it updates the
 *     graph by adding the appropriate "edge". It adds the exporter's ID to the
 *     importer's `dependencies` set, and the importer's ID to the exporter's
 *     `dependents` set.
 * 4.  **Robust Linking:** It creates both a granular, symbol-to-symbol link (where
 *     possible) and a more general, file-to-symbol link. This ensures that even if
 *     the exact importing symbol cannot be determined, a file-level dependency is
 *     still correctly established.
 */
import traverse, { NodePath } from '@babel/traverse';
import type { Node, ImportDeclaration } from '@babel/types';
import type { SymbolGraph } from '../types';
import { PathResolver } from '../pathResolver';
import { resolveExport } from '../astUtils';

type AstCache = Map<string, Node>;

function getIdentifierName(node: import('@babel/types').Identifier | import('@babel/types').StringLiteral): string {
  return node.type === 'Identifier' ? node.name : node.value;
}

/**
 * Pass 3: Connects the symbol nodes by analyzing import statements.
 * @param astCache - The cache of ASTs generated by Pass 1.
 * @param graph - The graph instance to be populated. This function mutates the graph.
 * @param pathResolver - The utility for resolving module paths.
 */
export function linkDependencies(
  astCache: AstCache,
  graph: SymbolGraph,
  pathResolver: PathResolver,
  errors: string[]
): void {
  for (const [filePath, ast] of astCache.entries()) {
    traverse(ast, {
      ImportDeclaration(path: NodePath<ImportDeclaration>) {
        
        const sourcePath = pathResolver.resolve(filePath, path.node.source.value, errors);
        
        if (!sourcePath) return; // Cannot resolve import, likely a node_module 

        for (const specifier of path.node.specifiers) {
          let importedName: string | null = null;
          if (specifier.type === 'ImportSpecifier') {
            importedName = getIdentifierName(specifier.imported);
          } else if (specifier.type === 'ImportDefaultSpecifier') {
            importedName = 'default';
          }

          if (importedName) {
            const exporterId = resolveExport(sourcePath, importedName, astCache, pathResolver, errors);
            if (exporterId && graph.has(exporterId)) {
              const importerFileNode = graph.get(filePath)!;
              const exporterNode = graph.get(exporterId)!;

              // Always create a robust, file-level dependency link.
              importerFileNode.dependencies.add(exporterId);
              exporterNode.dependents.add(filePath);

              // Attempt to create a more granular, symbol-level link.
              const binding = path.scope.getBinding(specifier.local.name);
              if (binding) {
                for (const refPath of binding.referencePaths) {
                  const importerScope = refPath.findParent(
                    p =>
                      p.isFunctionDeclaration() ||
                      p.isClassDeclaration() ||
                      p.isVariableDeclarator()
                  );
                  if (
                    importerScope?.isVariableDeclarator() &&
                    importerScope.node.id.type === 'Identifier'
                  ) {
                    const importerId = `${filePath}#${importerScope.node.id.name}`;
                    if (graph.has(importerId)) {
                      graph.get(importerId)!.dependencies.add(exporterId);
                      exporterNode.dependents.add(importerId);
                    }
                  } else if (
                    (importerScope?.isFunctionDeclaration() ||
                      importerScope?.isClassDeclaration()) &&
                    importerScope.node.id
                  ) {
                    const importerId = `${filePath}#${importerScope.node.id.name}`;
                    if (graph.has(importerId)) {
                      graph.get(importerId)!.dependencies.add(exporterId);
                      exporterNode.dependents.add(importerId);
                    }
                  }
                }
              }
            } else if (exporterId) {
              // --- NEW DEBUG LINE 3: Log if the exporter ID exists but the node is missing in the graph ---
              console.log(`[Linker DEBUG] MISSING GRAPH NODE: Exporter ID ${exporterId} exists but is not in the graph.`);
          }
          }
        }
      },
    });
  }
}